# PHP基礎（オブジェクト指向）

## オブジェクト指向とは?
オブジェクトは「もの」、指向は「〜を中心に」という意味で、オブジェクト指向を簡単に説明するとオブジェクト（もの）を中心にした考え方ということです。
例えば、現実のショップもECサイトも「商品」「ユーザー」「カート」などのオブジェクトが組み合わさってできていると考えることができます。


### プログラムでのオブジェクト
プログラムの世界でもオブジェクトをコードで再現する仕組みが用意されています。
この仕組みを使うと、それぞれのオブジェクトに関するプログラムの役割が明確化し、それらを組み立てるようにプログラムを書くことができます。

---

## クラスとインスタンス

### クラス
オブジェクト指向では「クラス」というオブジェクトの設計図を作成し、クラス（設計図）を元にオブジェクト（実体）を生成します。<br>

### クラスの書き方
「class クラス名」と定義し、「{}」の間に、そのクラスの内容を書いていきます。<br>
クラス名は大文字で始めます。<br>

```php
  class クラス名 {
    // クラスの内容を記述する
  }
```

<br><br>

### インスタンス
クラス（設計図）を元に生成された実体を「インスタンス」と呼びます。<br>
インスタンスとオブジェクトは同じ意味で使われます。<br>
インスタンスは「new」を用いて「new クラス名()」で生成できます。<br>
「$変数名 = new クラス名()」のようにすることで生成したインスタンスを変数に代入しています。<br>
なお、インスタンスの生成はクラスの外で行います。<br>

---

<br><br>

## プロパティとメソッド
クラス（設計図）にはそのインスタンス（実体）が持つ「プロパティ」と「メソッド」の２つを定義します。<br>
プロパティとはインスタンスが持つデータのことで、メソッドはインスタンスに関連する処理（関数）のことです。<br>

### プロパティ
プロパティ（インスタンスが持つデータのこと)<br>
「public $プロパティ名」のように定義します（publicについては後ほど説明するので気にしないでください）。<br>

```php
  class クラス名 {
    public $プロパティ名;
  }
```
<br><br>

### プロパティへのアクセス
「インスタンス->プロパティ名」とすることで、そのインスタンスのプロパティにアクセスすることができます（プロパティ名に$は不要）。<br>
このように、プロパティにアクセスする際には「->」（ハイフン「-」と大なり「>」）を用います。<br>

```php
  class クラス名 {
    public $プロパティ名;
  }
$変数名 = new クラス名();
$変数名 ->  $プロパティ名 = '値'; //プロパティに値をセットする
echo $変数名 ->  $プロパティ名;

//結果： 値
```

<br><br>

### メソッド
メソッドとはそれぞれのインスタンスが持つ関数のことです。<br>
メソッドは「public function メソッド名()」のように定義します。<br>
また、「インスタンス->メソッド名()」のようにメソッドにアクセスする（メソッドを呼び出す）ことができます。<br>

```php
  class クラス名 {
    public  function メソッド名();
    echo 'Hello World!!';
  }
  $変数名 = new クラス名();
  $変数名 -> メソッド名();

  // 結果： Hello World!!
```
<br><br>

### $this
メソッド内でインスタンスのプロパティやメソッドにアクセスしたい時には「$this」という特殊な変数を用います。<br>
$thisはクラス内のメソッドの定義の中でのみ使用できます。<br>
$thisはメソッドが呼ばれた時に、そのメソッドを呼び出しているインスタンスに置き換えられます。<br>

```php
  class クラス名 {
    public $プロパティ名;
    public  function メソッド名();
    echo 'Hello'.$this -> プロパティ名;
  }
  $変数名 = new クラス名();
  $変数名 ->  $プロパティ名 = '値';
  $変数名 -> メソッド名();

  // 結果： Hello 値
```

<br><br>

### コンストラクタ
**「__construct」** という特別なメソッドを定義すると、newを用いてインスタンスを生成するときに、このメソッドが自動的に呼ばれます。<br>
このようなインスタンスの生成時に呼ばれるメソッドのことを一般的に「コンストラクタ」といいます。<br>

```php
  class クラス名 {
    public $プロパティ名;
    public  function __construct();
    echo 'Hello World!!';
  }
  $変数名 = new クラス名(); //コンストラクタが自動的に呼ばれる。

  // 結果： Hello World!!
```

<br><br>

### コンストラクタと引数
__constructメソッドは引数をとることができます。<br>
newを用いてインスタンスを生成する際には引数を与えることができ、その引数の値が__constructメソッドに渡されます。<br>

```php
  class クラス名 {
    public $プロパティ名;
    public  function __construct($プロパティ名); //引数を受け取る
    echo $name;
  }
  $変数名 = new クラス名('値'); //引数を与えられる

  // 結果： 値
```

<br><br>

### コンストラクタとプロパティ
__constructメソッド内で、$thisを用いてインスタンスのプロパティに値をセットすることができます。<br>
インスタンスの生成時にプロパティをセットすることができるので便利です。<br>

```php
  class クラス名 {
    public $プロパティ名;
    public  function __construct($プロパティ名) {
      $this ->プロパティ名 = $プロパティ名;
      // インスタンスのプロパティに値をセットしている
    }
  }
  $変数名 = new クラス名('値'); 
  echo $変数->プロパティ名;

  // 結果： 値
```
---

<br><br>

## カプセル化
**「カプセル化」** とは、オブジェクト指向の重要な機能の１つで、
使い手に必要ないものを隠してしまうことを言います。<br>
例えば、パソコンの回路などはパソコンの内部に隠されており、ユーザーはキーボードなどの限られた部分しか操作することができません。回路を隠す（カプセル化をする）と回路に触れてパソコンを壊してしまう危険を回避できます。
プログラミングでもこのような「カプセル化」という仕組みがあります。

### クラスでのカプセル化
自分がクラスを作る際には、他の人がそのクラスを使いやすいように、その人に使ってほしい機能は公開し、クラスの外で使ってほしくない機能は隠します。<br>
使える機能を制限することで他の人はどの機能を使えばいいかが分かりやすく、また、安全にクラスを利用することができます<br>

<br><br>

### publicとprivate
カプセル化とは、クラスのプロパティとメソッドへのアクセスを制限することを言います。<br>
クラスの外部からアクセスできるようにするには「public」を、アクセスできないようにするには「private」を用いて定義します。<br>
プロパティは基本的にアクセス権をprivateにします。<br>

<br><br>

### ゲッター
プロパティのアクセス権をprivateにするとプロパティの値をクラスの外から取り出すことができなくなります。そこで、プロパティの値を返すだけのメソッドを定義します。<br>
このような、プロパティの値を返すだけのメソッドを特に **「ゲッター」** といいます。ゲッターは「getプロパティ名」のように命名するのが一般的です。

```php
  class クラス名 {
    private $プロパティ名;
    public  function __construct($プロパティ名) {
      $this ->プロパティ名 = $プロパティ名;
      // クラス内なのでアクセスできる
    }

    //ゲッターの定義
    public function getプロパティ名() { 
      retrun $this->プロパティ名; // プロパティの値を返す
      // クラス内なのでアクセスできる
    }
  }
  $変数名 = new クラス名('値'); 
  echo $変数->getプロパティ名();

  // 結果： 値
```

<br><br>

### セッター
プロパティのアクセス権をprivateにするとプロパティの値をクラスの外から変更できなくなります。<br>
そこで、プロパティの値を変更するメソッドを定義します。<br>
このような、プロパティの値を変更するメソッドを特に **「セッター」** といいます。<br>
セッターは「setプロパティ名」のように命名するのが一般的です。<br>

```php
  class クラス名 {
    private $プロパティ名;
    public  function __construct($プロパティ名) {
      $this ->プロパティ名 = $プロパティ名;
      // クラス内なのでアクセスできる
    }

    //セッターの定義
    public function setプロパティ名($プロパティ名) { 
      $this->プロパティ名 = $プロパティ名; 
      // クラス内なのでアクセスできる
    }
  }
  $変数名 = new クラス名('値'); 
  $変数名->setプロパティ名('値');
  // セッターを用いて値をセット

  echo $変数->setプロパティ名();

  // 結果： 値
```

---

<br><br>

## クラスプロパティ
インスタンスの数は個々のインスタンスではなく、クラス全体で管理する必要があります。<br>
「クラスプロパティ」というものを用いるとこれを実現できます。

個々のインスタンスがもつデータ（プロパティ）ではなく、クラスがもつデータをクラスプロパティといいます。<br>
クラスプロパティは **「static」** を用いて定義します。<br>
クラスプロパティにアクセスする場合は「クラス名::$クラスプロパティ名」のように「::」（コロン「:」２つ）を用います（$の位置に気をつけてください）。

```php
  class クラス名 {
    public static $プロパティ名 = '値'; //初期値（省略可）
    // staticをつけるとクラスプロパティになる
  }
  echo Menu::$プロパティ名;
  // クラスプロパティにアクセス

  // 結果： 値
```

<br><br>

## self
クラス内でクラスプロパティにアクセスする際は **「self」** という特殊な変数を用います。<br>
selfは、クラスの中で使うとそのクラス自身のことを指し示し、 **「self::$クラスプロパティ名」** のように使います（$の位置に気をつけてください）。<br>
このselfを用いてコンストラクタの中でクラスプロパティ$countの値を変更しましょう。<br>

```php
  class クラス名 {
    public static $プロパティ名 = '値'; 
    public function __construct(){
       self::$プロパティ名++;
      //インスタンスが生成されるたびにコンストラクタの中で
      //クラスプロパティ「$プロパティ名」に１を足している
    }
```
<br><br>

## クラスメソッド
$プロパティ名のアクセス権をprivateにするとクラスの外から$プロパティ名にアクセスできなくなるので$プロパティ名のゲッターを定義します。<br>
個々のインスタンスのデータに関係ない処理を行いたい時には「クラスメソッド」を用います。<br>
クラスメソッドは「static」を用いて定義し、 **「クラス名::クラスメソッド名」** のように呼び出します。<br>

```php
  class クラス名 {
    private static $プロパティ名 = '値'; 
    // クラスの外で書き換えられては困るのでprivateにする

    public static function getプロパティ名(){
    // クラスメソッドの定義

      return self::$プロパティ名;
    }

   echo クラス名::getプロパティ名();
    //  クラスメソッドの呼び出し
```

---

<br><br>

## 継承

### 継承とは
すでに定義されているクラスのプロパティやメソッドを別のクラスに引き継ぐことを **「継承」** といいます。<br>
このとき引き継がれる元のクラスを **「親クラス」** 、継承してできる新しいクラスを **「子クラス」** と呼びます。<br>
子クラスは、親クラスのプロパティやメソッドを全て引き継いだ上で、独自の機能を追加することができます。

<br><br>

### 継承の書き方
継承を用いて新しく子クラスを定義するときは、 **「extends」** を用いて「class 子クラス名 extends 親クラス名」のように書きます。

```php
  class 子クラス名 extends 親クラス名 {
    //親クラスを継承する
  }
```

<br><br>

### 継承の使い方
子クラスは親クラスのプロパティやメソッドを引き継いでいるので、親クラスで定義されているメソッドを呼び出すことができます。

```php
親クラス

  class 親クラス名 {
    public function __construct($プロパティ名){
      $this->プロパティ名 = $プロパティ名;
    }
    // 親クラスのコンストラクタ

    public function getプロパティ名() {
      return $this->プロパティ名;
    // 親クラスのメソッド
    }
  }
```

```php
子クラス

  class 子クラス名 extends 親クラス名 {
    //親クラスを継承
  }
  $プロパティ名 = new 子クラス名('値')；
  //親クラスのコンストラクタが実行される

  echo $プロパティ名->getプロパティ名();
  //親クラスのメソッドの呼び出し
```

<br><br>

### 独自プロパティ、独自メソッド
子クラスには独自のプロパティを追加することができます。<br>
子クラスには独自のメソッドも定義することができます。

<br>

### メソッドの呼び出し
子クラスのメソッドを呼ぶ際には次のようにメソッドが検索されます。<br>
子クラスにメソッドが定義されている場合にはそのメソッドが、定義されていない場合には親クラスのメソッドが呼び出されます。

---

<br><br>

## クラスによって処理を分ける

###  instanceof
**「instanceof」** を用いると、あるインスタンスが特定のクラスのインスタンスであるかどうか判別することができます。<br>
「インスタンス instanceof クラス名」のようにすると、インスタンスが指定したクラスのインスタンスである場合は「true」に、そうでない場合は「false」になります。

```php
  if($プロパティ名 instanceof クラス名) {
    // 処理内容
  }
```

<br><br>

### オーバーライド
同じ名前のメソッドを子クラスで定義するとメソッドの中身を上書きすることができます。<br>
このようなメソッドの上書きを「オーバーライド」と言います。

<br><br>

### 子クラスとアクセス権
プロパティのアクセス権がprivateだとクラス外からそのプロパティに直接アクセス出来ないことは先ほど言いましたが、
実はprivateなプロパティには子クラスからもアクセスすることができません。

<br><br>

### protected
子クラスから親クラスで定義したプロパティにアクセスしたい場合は、そのプロパティのアクセス権を **「protected」** にします。<br>
アクセス権がprotectedのプロパティには、そのクラス内からと、そのクラスを継承している子クラス内からのみアクセスすることができます。

```php
親クラス

  class Menu {
    protected $プロパティ名;
    // アクセス権は「protected」
  }
```

```php
子クラス

  class 子クラス extends 親クラス {
    public function __construct() {
      $this->プロパティ名 = $プロパティ名；
      // 親クラスでアクセス権を「protected」にしているためアクセスができる
    }
  }
```

<br><br>

### アクセス権まとめ
「public」「protected」「private」の3つのアクセス権について<br>
* public: どこからでもアクセス可能<br>
* protected: そのクラスと子クラス内からのみアクセス可能<br>
* private: そのクラス内からのみアクセス可能<br>

| アクセス権 | public | protected | private |
|:-:|:-:|:-:|:-:|
| クラス内 | ○ | ○ | ○ |
| 子クラス内 | ○ | ○ | X |
| クラス、子クラスの外 | ○ | X | X |


<br><br>

## コードをまとめる
親クラスのコンストラクタと子クラスのコンストラクタはで多くの部分が重複している場合<br>
このままでは重複部分を変更するときに2箇所とも変更する必要があり、管理するのが大変です。<br>
重複するコードを1箇所にまとめることで解決できます。

<br><br>

### parent

オーバーライドの際に親クラスで定義したメソッドを呼び出したいときには、「parent」を用いて「parent::メソッド名」のようにします。<br>
「parent::メソッド名」を記述した場所で、親クラスのメソッドが実行されます。<br>
これを用いると先ほどのコンストラクタがすっきり書けます。

```php
  class 子クラス extends 親クラス {
    public function __construct(引数){
      parent::__construct(引数);
      //親クラスの__constuructメソッドを呼び出す
      $spiciness
        $this->プロパティ名 = $プロパティ名;
    }
  }
  $プロパティ名 =new クラス名('値');
  echo $プロパティ名->getプロパティ名();
```

<br><br>

## クエリ情報
URLの末尾の「?」以降に「キー名=値」の形で簡単な情報をのせることができます。これをクエリ情報といい、クエリ情報を用いてリンク先のページに情報を渡す（送信する）ことができます。

```php
<a href="hoge.php?キー名='値'">

<a hlef="hoge.php?キー名=<?php echo $プロパティ名->getプロパティ名() ?>"></a>
```

<br><br>

## $_GET 
クエリ情報を受け取るには「$_GET」を使用します。<br>
$_GETにはクエリ情報が連想配列として入っています。<br>
よって、$_GET['キー名']のように値を取り出すことができます。<br>

```php
echo $_GET['キー名'];
```