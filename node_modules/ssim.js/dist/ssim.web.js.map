{"version":3,"sources":["webpack://ssim/webpack/universalModuleDefinition","webpack://ssim/webpack/bootstrap","webpack://ssim/./src/math.ts","webpack://ssim/./src/matlab/index.ts","webpack://ssim/./src/matlab/conv2.ts","webpack://ssim/./src/matlab/ones.ts","webpack://ssim/./src/matlab/internal/numbers.ts","webpack://ssim/./src/matlab/sub.ts","webpack://ssim/./src/matlab/zeros.ts","webpack://ssim/./src/matlab/filter2.ts","webpack://ssim/./src/matlab/mod.ts","webpack://ssim/./src/matlab/padarray.ts","webpack://ssim/./src/index.ts","webpack://ssim/./src/matlab/fspecial.ts","webpack://ssim/./src/matlab/imfilter.ts","webpack://ssim/./src/matlab/normpdf.ts","webpack://ssim/./src/matlab/rgb2gray.ts","webpack://ssim/./src/matlab/skip2d.ts","webpack://ssim/./src/matlab/transpose.ts","webpack://ssim/./src/ssim.ts","webpack://ssim/./src/originalSsim.ts","webpack://ssim/./src/bezkrovnySsim.ts","webpack://ssim/./src/downsample.ts","webpack://ssim/./src/defaults.ts","webpack://ssim/./src/weberSsim.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","average","xn","sum","length","out","x","sum2d","data","add2dScalar","increase","ref","width","height","Array","multiply2d","A","multiplier","multiply2dScalar","ref1","ref2","multiply2dMx","Math","floor","offset","y","add2dMx","decrease","subtract2dMx","divisor","divide2dScalar","divide2dMx","values","avg","varx","values1","values2","average1","average2","cov","mxConv2","b","shape","refWidth","refHeight","cWidth","cHeight","zeros","r1","c1","br1c1","j","reshape","boxConv","a","convn","ones","isBoxKernel","expected","b1","b2","mb","max","nb","temp","ma","na","rowStart","ceil","colStart","sub","args","numbers","num","size","h","X","conv2","rotate1802d","padHorizontal","pad","mirrored","B","concatHorizontal","mirrorHorizonal","mod","padVertical","concat","concatVertical","mirrorVertical","_padval","_direction","padHeight","padWidth","abs","fastPadding","ssimTargets","fast","original","originalSsim","bezkrovny","bezkrovnySsim","weber","weberSsim","getOptions","userOptions","options","defaults","keys","forEach","option","Error","k1","k2","ssim","join","validateOptions","image1","image2","start","Date","getTime","ssimMap","pixels1","pixels2","comparison","pixels","downsample","toResize","rgb2gray","toGrayScale","validateDimensions","mssim","undefined","mean2d","ssim_map","performance","_type","hsize","σ","gauss","exp","gaussianFilter2d","rangeSquare2d","total","divide2d","f","resSize","frows","fcols","padarray","slice","push","padMatrix","getConv2Size","filter2","µ","z","uint8Array","Uint8Array","from","startRow","everyRow","endRow","startCol","everyCol","endCol","Ai","Aj","w","normpdf","getRange","windowSize","L","bitDepth","c2","wt","transpose","μ1","μ2","μ1Sq","square2d","μ2Sq","μ12","pixels1Sq","pixels2Sq","σ1Sq","subtract2d","σ2Sq","σ12","num1","add2d","num2","denom1","denom2","genSSIM","numerator1","numerator2","denominator1","denominator2","genUQI","fspecial","windowSsim","σSqx","variance","σSqy","covariance","counter","windowWidth","min","windowHeight","imageDownsample","filter","imdown","imfilter","skip2d","maxSize","factor","round","lpf","originalDownsample","edgeHandler","sumArray","matrixWidth","rightEdge","bottomEdge","bottomRightEdge","partialSumMatrix1","matrixHeight","Int32Array","partialSumMatrix2","data1","data2","windowMatrix","sumMatrix","imageWidth","imageHeight","windows","windowSums","windowVariance","sums","windowSquared","varX","v","mean","sumSquares","squareMeans","windowCovariance","sums1","sums2","covXY","pixels1Rounded","pixels2Rounded","variance1","variance2","ssims","meanx","meany","vary"],"mappings":"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","file":"ssim.web.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ssim\"] = factory();\n\telse\n\t\troot[\"ssim\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","/**\n * Generates all basic arithmetic and matrix computations required\n *\n * Most of these methods use plain for loops and reduce nested calls. This results in about ~100x\n * improvement on SSIM computation for 512x512 images on recent versions of node (~v6.7) over\n * implementations using map or reduce.\n *\n * @namespace math\n */\nimport { Matrix } from './types'\n\n/**\n * Computes the mean value of a given array. It is the sum of a list of numbers divided by the\n * number of numbers in the list.\n *\n * @method average\n * @param {Number[]} xn - The target array\n * @returns {Number} average - The mean value of all elements within the array\n * @public\n * @memberOf math\n * @since 0.0.1\n */\nexport function average(xn: number[]): number {\n  return sum(xn) / xn.length\n}\n\n/**\n * Computes the sum of a given array. It adds all values within the array and returns the total\n *\n * @method sum\n * @param {Number[]} xn - The target array\n * @returns {Number} sum - The total value\n * @private\n * @memberOf math\n * @since 0.0.1\n */\nexport function sum(xn: number[]): number {\n  let out = 0\n\n  for (let x = 0; x < xn.length; x++) {\n    out += xn[x]\n  }\n  return out\n}\n\n/**\n * Computes the largest integer less than or equal to a given number for each member of a given\n * array.\n *\n * @method floor\n * @param {Number[]} xn - The target array\n * @returns {Number[]} floorArr - An array with the Math.floor value for each element of the target\n * array\n * @private\n * @memberOf math\n * @since 0.0.1\n */\nexport function floor(xn: number[]): number[] {\n  const out = new Array(xn.length)\n\n  for (let x = 0; x < xn.length; x++) {\n    out[x] = Math.floor(xn[x])\n  }\n\n  return out\n}\n\n/**\n * Computes the sum of all elements within a matrix\n *\n * @method sum2d\n * @param {Matrix} A - The input matrix\n * @returns {Number} sum - The total value of adding each cell\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function sum2d({ data }: Matrix): number {\n  let out = 0\n\n  for (let x = 0; x < data.length; x++) {\n    out += data[x]\n  }\n\n  return out\n}\n\n/**\n * Adds values of two matrices of the same size\n *\n * @method add2dMx\n * @param {Matrix} A - The first input matrix\n * @param {Matrix} B - The second input matrix\n * @returns {Matrix} out - A matrix with a cell-by-cell sum of `A` and `B`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction add2dMx(\n  { data: ref1, width, height }: Matrix,\n  { data: ref2 }: Matrix\n): Matrix {\n  const data = new Array(ref1.length)\n\n  for (let x = 0; x < height; x++) {\n    const offset = x * width\n\n    for (let y = 0; y < width; y++) {\n      data[offset + y] = ref1[offset + y] + ref2[offset + y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Subtracts values of second matrix from the first one. It assumes both matrices are of the same\n * size\n *\n * @method subtract2dMx\n * @param {Matrix} A - The first input matrix\n * @param {Matrix} B - The second input matrix\n * @returns {Matrix} out - A matrix with a cell-by-cell subtraction of `A` minus `B`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction subtract2dMx(\n  { data: ref1, width, height }: Matrix,\n  { data: ref2 }: Matrix\n): Matrix {\n  const data = new Array(ref1.length)\n\n  for (let x = 0; x < height; x++) {\n    const offset = x * width\n\n    for (let y = 0; y < width; y++) {\n      data[offset + y] = ref1[offset + y] - ref2[offset + y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Adds a constant value two each matrix cell\n *\n * @method add2dScalar\n * @param {Matrix} A - The first input matrix\n * @param {Number} increase - The value to add\n * @returns {Matrix} B - The cell-by-cell matrix sum of `A` and `increase`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction add2dScalar(\n  { data: ref, width, height }: Matrix,\n  increase: number\n): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < ref.length; x++) {\n    data[x] = ref[x] + increase\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Adds values of two matrices of the same size or a matrix and a constant\n *\n * @method add2d\n * @param {Matrix} A - The first input matrix\n * @param {Matrix|Number} increase - The second input matrix or the constant value\n * @returns {Matrix} B - A matrix with a cell-by-cell sum of the first and second parameters\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function add2d(A: Matrix, increase: Matrix | number): Matrix {\n  if (typeof increase === 'number') {\n    return add2dScalar(A, increase)\n  }\n  return add2dMx(A, increase)\n}\n\n/**\n * Subtracts values of two matrices of the same size or a matrix and a constant\n *\n * @method subtract2d\n * @param {Matrix} A - The first input matrix\n * @param {Matrix|Number} decrease - The second input matrix or the constant value\n * @returns {Matrix} B - A matrix with a cell-by-cell subtraction of the first parameter minus the\n * second one\n * @public\n * @memberOf math\n */\nexport function subtract2d(A: Matrix, decrease: Matrix | number): Matrix {\n  if (typeof decrease === 'number') {\n    return add2dScalar(A, -decrease)\n  }\n  return subtract2dMx(A, decrease)\n}\n\n/**\n * Divides each matrix cell by a constant value\n *\n * @method divide2dScalar\n * @param {Matrix} A - The first input matrix\n * @param {Number} divisor - The value to divide by\n * @returns {Matrix} B - The cell-by-cell matrix divison of `A` and `divisor`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction divide2dScalar(\n  { data: ref, width, height }: Matrix,\n  divisor: number\n): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < ref.length; x++) {\n    data[x] = ref[x] / divisor\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Divides, cell-by-cell, values of two matrices of the same size\n *\n * @method divide2dMx\n * @param {Matrix} A - The first input matrix\n * @param {Matrix} B - The second input matrix\n * @returns {Matrix} out - A matrix with a cell-by-cell division of `A`/`B`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction divide2dMx(\n  { data: ref1, width, height }: Matrix,\n  { data: ref2 }: Matrix\n): Matrix {\n  const data = new Array(ref1.length)\n\n  for (let x = 0; x < ref1.length; x++) {\n    data[x] = ref1[x] / ref2[x]\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Divides values of two matrices of the same size or between a matrix and a constant\n *\n * @method divide2d\n * @param {Matrix} A - The first input matrix\n * @param {Matrix|Number} divisor - The second input matrix or the constant value\n * @returns {Matrix} B - A matrix with the cell-by-cell division of the first and second parameters\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function divide2d(A: Matrix, divisor: Matrix | number): Matrix {\n  if (typeof divisor === 'number') {\n    return divide2dScalar(A, divisor)\n  }\n  return divide2dMx(A, divisor)\n}\n\n/**\n * Multiplies each matrix cell by a constant value\n *\n * @method multiply2dScalar\n * @param {Matrix} A - The first input matrix\n * @param {Number} multiplier - The value to multiply each cell with\n * @returns {Matrix} B - The cell-by-cell matrix multiplication of `A` and `multiplier`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction multiply2dScalar(\n  { data: ref, width, height }: Matrix,\n  multiplier: number\n): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < ref.length; x++) {\n    data[x] = ref[x] * multiplier\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Multiplies, cell-by-cell, values of two matrices of the same size\n *\n * @method multiply2dMx\n * @param {Matrix} A - The first input matrix\n * @param {Matrix} B - The second input matrix\n * @returns {Matrix} out - A matrix with a cell-by-cell multiplication of `A` * `B`\n * @private\n * @memberOf math\n * @since 0.0.2\n */\nfunction multiply2dMx(\n  { data: ref1, width, height }: Matrix,\n  { data: ref2 }: Matrix\n): Matrix {\n  const data = new Array(ref1.length)\n\n  for (let x = 0; x < ref1.length; x++) {\n    data[x] = ref1[x] * ref2[x]\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Multiplies values of two matrices of the same size or between a matrix and a constant\n *\n * @method multiply2d\n * @param {Matrix} A - The first input matrix\n * @param {Matrix|Number} multiplier - The second input matrix or the constant value\n * @returns {Matrix} out - A matrix with the cell-by-cell multiplication of the first and second\n * parameters\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function multiply2d(A: Matrix, multiplier: Matrix | number): Matrix {\n  if (typeof multiplier === 'number') {\n    return multiply2dScalar(A, multiplier)\n  }\n  return multiply2dMx(A, multiplier)\n}\n\n/**\n * Generates the cell-by-cell square value of a target matrix\n *\n * @method square2d\n * @param {Matrix} A - The target matrix\n * @returns {Matrix} B - A matrix with squared value of each cell\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function square2d(A: Matrix): Matrix {\n  return multiply2d(A, A)\n}\n\n/**\n * Calculates the total mean value for a given matrix\n *\n * @method mean2d\n * @param {Matrix} A - The target matrix\n * @returns {Number} mean - The total mean of each cell\n * @public\n * @memberOf math\n * @since 0.0.2\n */\nexport function mean2d(A: Matrix): number {\n  return sum2d(A) / A.data.length\n}\n\n/**\n * Computes the variance for a given array\n *\n * @method variance\n * @param {Array<Number>} values - The target array\n * @param {Number} [avg=average(values)] - If specified, it will use this values as the average of\n * the array values. If not, it will compute the actual average\n * @returns {Number} varx - The resulting variance value\n * @public\n * @memberOf math\n */\nexport function variance(\n  values: number[],\n  avg: number = average(values)\n): number {\n  let varx = 0\n  let i = values.length\n\n  while (i--) {\n    varx += (values[i] - avg) ** 2\n  }\n\n  return varx / values.length\n}\n\n/**\n * Computes the covariance between 2 arrays\n *\n * @method covariance\n * @param {Array<Number>} values1 - The first target array\n * @param {Array<Number>} values2 - The second target array\n * @param {Number} [average1=average(values)] - If specified, it will use this values as the average\n * of the first array. If not, it will compute the actual average\n * @param {Number} [average2=average(values)] - If specified, it will use this values as the average\n * of the second array. If not, it will compute the actual average\n * @returns {Number} cov - The resulting covariance\n * @public\n * @memberOf math\n */\nexport function covariance(\n  values1: number[],\n  values2: number[],\n  average1: number = average(values1),\n  average2: number = average(values2)\n): number {\n  let cov = 0\n  let i = values1.length\n\n  while (i--) {\n    cov += (values1[i] - average1) * (values2[i] - average2)\n  }\n\n  return cov / values1.length\n}\n","/**\n * Implements Matlab functions or functionality.\n *\n * The goal here is not a perfect reproduction of matlab logic but just a minimal implementation\n * needed to correctly reproduce the SSIM matlab script.\n *\n * That means that functionality used will be implemented but additional / unused parameters will\n * not.\n *\n * @namespace matlab\n */\nexport * from './conv2'\nexport * from './filter2'\nexport * from './fspecial'\nexport * from './imfilter'\nexport * from './normpdf'\nexport * from './ones'\nexport * from './padarray'\nexport * from './rgb2gray'\nexport * from './skip2d'\nexport * from './sub'\nexport * from './transpose'\nexport * from './zeros'\n","import { multiply2d } from '../math'\nimport { ones } from './ones'\nimport { sub } from './sub'\nimport { zeros } from './zeros'\nimport { Matrix, Shape } from '../types'\n\n/**\n * `C = conv2(a,b)` computes the two-dimensional convolution of matrices `a` and `b`. If one of\n * these matrices describes a two-dimensional finite impulse response (FIR) filter, the other matrix\n * is filtered in two dimensions. The size of `c` is determined as follows:\n *\n * ```\n * if [ma,na] = size(a), [mb,nb] = size(b), and [mc,nc] = size(c), then\n * mc = max([ma+mb-1,ma,mb]) and nc = max([na+nb-1,na,nb]).\n * ```\n *\n * `shape` returns a subsection of the two-dimensional convolution, based on one of these values for\n * the parameter:\n *\n * - **full**: Returns the full two-dimensional convolution (default).\n * - **same**: Returns the central part of the convolution of the same size as `a`.\n * - **valid**: Returns only those parts of the convolution that are computed without the\n *   zero-padded edges. Using this option, `size(c) === max([ma-max(0,mb-1),na-max(0,nb-1)],0)`\n *\n * @method mxConv2\n * @param {Matrix} a - The first matrix\n * @param {Matrix} b - The second matrix\n * @param {String} [shape='full'] - One of 'full' / 'same' / 'valid'\n * @returns {Matrix} c - Returns the convolution filtered by `shape`\n * @private\n * @memberOf matlab\n */\nfunction mxConv2(\n  { data: ref, width: refWidth, height: refHeight }: Matrix,\n  b: Matrix,\n  shape: Shape = 'full'\n): Matrix {\n  const cWidth = refWidth + b.width - 1\n  const cHeight = refHeight + b.height - 1\n  const { data } = zeros(cHeight, cWidth)\n\n  /**\n   * Computing the convolution is the most computentionally intensive task for SSIM and we do it\n   * several times.\n   *\n   * This section has been optimized for performance and readability suffers.\n   */\n  for (let r1 = 0; r1 < b.height; r1++) {\n    for (let c1 = 0; c1 < b.width; c1++) {\n      const br1c1 = b.data[r1 * b.width + c1]\n\n      if (br1c1) {\n        for (let i = 0; i < refHeight; i++) {\n          for (let j = 0; j < refWidth; j++) {\n            data[(i + r1) * cWidth + j + c1] += ref[i * refWidth + j] * br1c1\n          }\n        }\n      }\n    }\n  }\n\n  const c = {\n    data,\n    width: cWidth,\n    height: cHeight,\n  }\n\n  return reshape(c, shape, refHeight, b.height, refWidth, b.width)\n}\n\n/**\n * `C = boxConv(a,b)` computes the two-dimensional convolution of a matrix `a` and box kernel `b`.\n *\n * The `shape` parameter returns a subsection of the two-dimensional convolution as defined by\n * mxConv2.\n *\n * @method boxConv\n * @param {Matrix} a - The first matrix\n * @param {Matrix} b - The box kernel\n * @param {String} [shape='full'] - One of 'full' / 'same' / 'valid'\n * @returns {Matrix} c - Returns the convolution filtered by `shape`\n * @private\n * @memberOf matlab\n */\nfunction boxConv(\n  a: Matrix,\n  { data, width, height }: Matrix,\n  shape: Shape = 'full'\n): Matrix {\n  const b1 = ones(height, 1)\n  const b2 = ones(1, width)\n  const out = convn(a, b1, b2, shape)\n\n  return multiply2d(out, data[0])\n}\n\n/**\n * Determines whether all values in an array are the same so that the kernel can be treated as a box\n * kernel\n *\n * @method isBoxKernel\n * @param {Matrix} a - The input matrix\n * @returns {Boolean} boxKernel - Returns true if all values in the matrix are the same, false\n * otherwise\n * @private\n * @memberOf matlab\n */\nfunction isBoxKernel({ data }: Matrix): boolean {\n  const expected = data[0]\n\n  for (let i = 1; i < data.length; i++) {\n    if (data[i] !== expected) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * `C = convn(a,b1, b2)` computes the two-dimensional convolution of matrices `a.*b1.*b2`.\n *\n * The size of `c` is determined as follows:\n *\n * ```\n * if [ma,na] = size(a), [mb] = size(b1), [nb] = size(b2) and [mc,nc] = size(c), then\n * mc = max([ma+mb-1,ma,mb]) and nc = max([na+nb-1,na,nb]).\n * ```\n *\n * `shape` returns a section of the two-dimensional convolution, based on one of these values for\n * the parameter:\n *\n * - **full**: Returns the full two-dimensional convolution (default).\n * - **same**: Returns the central part of the convolution of the same size as `a`.\n * - **valid**: Returns only those parts of the convolution that are computed without the\n *   zero-padded edges. Using this option, `size(c) === max([ma-max(0,mb-1),na-max(0,nb-1)],0)`\n *\n * This method mimics Matlab's `convn` method but limited to 2 1 dimensional kernels.\n *\n * @method convn\n * @param {Matrix} a - The first matrix\n * @param {Matrix} b1 - The first 1-D kernel\n * @param {Matrix} b2 - The second 1-D kernel\n * @param {String} [shape='full'] - One of 'full' / 'same' / 'valid'\n * @returns {Matrix} c - Returns the convolution filtered by `shape`\n * @private\n * @memberOf matlab\n */\nfunction convn(\n  a: Matrix,\n  b1: Matrix,\n  b2: Matrix,\n  shape: Shape = 'full'\n): Matrix {\n  const mb = Math.max(b1.height, b1.width)\n  const nb = Math.max(b2.height, b2.width)\n  const temp = mxConv2(a, b1, 'full')\n  const c = mxConv2(temp, b2, 'full')\n\n  return reshape(c, shape, a.height, mb, a.width, nb)\n}\n\n/**\n * `reshape` crops the resulting convolution matrix to match the values specified in `shape`.\n *\n * - **full**: Returns the input\n * - **same**: Returns the central part of the convolution of the same size as `a`.\n * - **valid**: Returns only those parts of the convolution that are computed without the\n *   zero-padded edges\n *\n * @method reshape\n * @param {Matrix} c - The output matrix\n * @param {String} shape - One of 'full' / 'same' / 'valid'\n * @param {Number} ma - The number of rows of the input matrix\n * @param {Number} mb - The number of rows of the input filter\n * @param {Number} na - The number of columns of the input matrix\n * @param {Number} nb - The number of columns of the input filter\n * @returns {Matrix} c - Returns the input convolution filtered by `shape`\n * @private\n * @memberOf matlab\n */\nfunction reshape(\n  c: Matrix,\n  shape: Shape,\n  ma: number,\n  mb: number,\n  na: number,\n  nb: number\n): Matrix {\n  if (shape === 'full') {\n    return c\n  } else if (shape === 'same') {\n    const rowStart = Math.ceil((c.height - ma) / 2)\n    const colStart = Math.ceil((c.width - na) / 2)\n\n    return sub(c, rowStart, ma, colStart, na)\n  }\n\n  return sub(c, mb - 1, ma - mb + 1, nb - 1, na - nb + 1)\n}\n\n/**\n * `C = conv2(a,b)` computes the two-dimensional convolution of matrices `a` and `b`. If one of\n * these matrices describes a two-dimensional finite impulse response (FIR) filter, the other matrix\n * is filtered in two dimensions.\n *\n * The size of `c` is determined as follows:\n *\n * ```\n * if [ma,na] = size(a), [mb,nb] = size(b), and [mc,nc] = size(c), then\n * mc = max([ma+mb-1,ma,mb]) and nc = max([na+nb-1,na,nb]).\n * ```\n *\n * `shape` returns a subsection of the two-dimensional convolution, based on one of these values for\n * the parameter:\n *\n * - **full**: Returns the full two-dimensional convolution (default).\n * - **same**: Returns the central part of the convolution of the same size as `a`.\n * - **valid**: Returns only those parts of the convolution that are computed without the\n *   zero-padded edges. Using this option, `size(c) === max([ma-max(0,mb-1),na-max(0,nb-1)],0)`\n *\n * Alternatively, 2 1-D filters may be provided as parameters, following the format:\n * `conv2(a, b1, b2, shape)`. This is similar to Matlab's implementation allowing any number of 1-D\n * filters to be applied but limited to 2\n *\n * This method mimics Matlab's `conv2` method.\n *\n * Given:\n * const A = rand(3);\n * const B = rand(4);\n *\n * @example conv2(A,B); // output is 6-by-6\n * {\n *   data: [\n *     0.1838, 0.2374, 0.9727, 1.2644, 0.7890, 0.3750,\n *     0.6929, 1.2019, 1.5499, 2.1733, 1.3325, 0.3096,\n *     0.5627, 1.5150, 2.3576, 3.1553, 2.5373, 1.0602,\n *     0.9986, 2.3811, 3.4302, 3.5128, 2.4489, 0.8462,\n *     0.3089, 1.1419, 1.8229, 2.1561, 1.6364, 0.6841,\n *     0.3287, 0.9347, 1.6464, 1.7928, 1.2422, 0.5423\n *   ],\n *   width: 6,\n *   height: 6\n * }\n *\n * @example conv2(A,B,'same') => // output is the same size as A: 3-by-3\n * {\n *   data: [\n *     2.3576, 3.1553, 2.5373,\n *     3.4302, 3.5128, 2.4489,\n *     1.8229, 2.1561, 1.6364\n *   ],\n *   width: 3,\n *   height: 3\n * }\n *\n * @method conv2\n * @param {Array} args - The list of arguments, see `mxConv2` and `convn` for the exact parameters\n * @returns {Matrix} c - Returns the convolution filtered by `shape`\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function conv2(\n  ...args: Parameters<typeof boxConv | typeof convn | typeof mxConv2>\n) {\n  if (args[2] && (args[2] as Matrix).data) {\n    return convn(...(args as Parameters<typeof convn>))\n  } else if (isBoxKernel(args[1])) {\n    return boxConv(...(args as Parameters<typeof boxConv>))\n  }\n  return mxConv2(...(args as Parameters<typeof mxConv2>))\n}\n","import { Matrix } from '../types'\nimport { numbers } from './internal/numbers'\n\n/**\n * Create a matrix of all ones\n *\n * This method mimics Matlab's `ones` method\n *\n * @method ones\n * @param {Number} height - The height of the matrix (rows)\n * @param {Number} [width=height] - The width of the matrix (columns)\n * @returns {Matrix} B - An n-by-m matrix of ones\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function ones(height: number, width: number = height): Matrix {\n  return numbers(height, width, 1)\n}\n","import { Matrix } from '../../types'\n\n/**\n * Create a matrix with each cell with the value of `num`\n *\n * @method numbers\n * @param {Number} height - The number of rows\n * @param {Number} width - The number of columns\n * @param {Number} num - The value to set on each cell\n * @returns {Matrix} B - An n-by-m matrix of `num`\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function numbers(height: number, width: number, num: number): Matrix {\n  const size = width * height\n  const data = new Array(size)\n\n  for (let x = 0; x < size; x++) {\n    data[x] = num\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\n\n/**\n * Crops the matrix and returns a window at position `[x,y]` of size `[xlen, ylen]` from the input\n * matrix\n *\n * @method sub\n * @param {Matrix} A - The input matrix\n * @param {Number} x - The starting x offset\n * @param {Number} height - The vertical size of the window\n * @param {Number} y - The starting y offset\n * @param {Number} width - The horizontal size of the window\n * @returns {Matrix} B - The generated subwindow from matrix `c`\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function sub(\n  { data: ref, width: refWidth }: Matrix,\n  x: number,\n  height: number,\n  y: number,\n  width: number\n): Matrix {\n  const data = new Array(width * height)\n\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      data[i * width + j] = ref[(y + i) * refWidth + x + j]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\nimport { numbers } from './internal/numbers'\n\n/**\n * Create a matrix of all zeros\n *\n * This method mimics Matlab's `zeros` method\n *\n * @method zeros\n * @param {Number} height - The height of the matrix (rows)\n * @param {Number} [width=height] - The width of the matrix (columns)\n * @returns {Matrix} B - An n-by-m matrix of zeros\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function zeros(height: number, width: number = height): Matrix {\n  return numbers(height, width, 0)\n}\n","import { conv2 } from './conv2'\nimport { Matrix, Shape } from '../types'\n\n/**\n * Rotates a matrix 180deg.\n *\n * @example\n * 1 2 3 4  becomes:  8 7 6 5\n * 5 6 7 8            4 3 2 1\n *\n * @method rotate1802d\n * @param {Matrix} mx - The input matrix\n * @returns {Matrix} out - The rotated matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction rotate1802d({ data: ref, width, height }: Matrix): Matrix {\n  const data = new Array(ref.length)\n\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      data[i * width + j] = ref[(height - 1 - i) * width + width - 1 - j]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Given a matrix X and a two-dimensional FIR filter h, filter2 rotates your filter matrix 180\n * degrees to create a convolution kernel. It then calls conv2, the two-dimensional convolution\n * function, to implement the filtering operation.\n *\n * This method mimics Matlab's `filter2` method\n *\n * @method filter2\n * @param {Matrix} h - The FIR filter\n * @param {Matrix} X - The input matrix\n * @param string [shape='same'] - The convolution shape\n * @returns {Matrix} conv - The 2D convolution of X with h\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function filter2(h: Matrix, X: Matrix, shape: Shape = 'same'): Matrix {\n  return conv2(X, rotate1802d(h), shape)\n}\n","/**\n * `M = mod(X,Y)` returns the remainder `X - Y.*floor(X./Y)` for nonzero `Y`, and returns `X`\n * otherwise. `mod(X,Y)` always differs from `X` by a multiple of `Y`.\n *\n * So long as operands `X` and `Y` are of the same sign, the function `mod(X,Y)` returns the same\n * result as does `rem(X,Y)`. However, for positive `X` and `Y`, `mod(-x,y) = rem(-x,y)+y`.\n *\n * The mod function is useful for congruence relationships: x and y are congruent (mod m) if and\n * only if mod(x,m) == mod(y,m).\n *\n * This method mimics Matlab's `mod` method\n *\n * @method mod\n * @param {Number} x - The dividend\n * @param {Numvwe} y - The divisor\n * @returns {Number} M - Returns the signed remainder after division.\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function mod(x: number, y: number): number {\n  return x - y * Math.floor(x / y)\n}\n","import { Matrix } from '../types'\nimport { mod } from './mod'\n\n/**\n * Mirrors a matrix horizontally.\n *\n * @example\n * 1 2 3 4  becomes:  4 3 2 1\n * 5 6 7 8            8 7 6 5\n *\n * @method mirrorHorizonal\n * @param {Matrix} A - The input matrix\n * @returns {Matrix} B - The rotated matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction mirrorHorizonal({ data: ref, width, height }: Matrix): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < height; x++) {\n    for (let y = 0; y < width; y++) {\n      data[x * width + y] = ref[x * width + width - 1 - y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Mirrors a matrix vertically.\n *\n * @example\n * 1 2 3 4  becomes:  9 0 F E\n * 5 6 7 8            5 6 7 8\n * 9 0 F E            1 2 3 4\n *\n * @method mirrorVertical\n * @param {Matrix} A - The input matrix\n * @returns {Matrix} B - The rotated matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction mirrorVertical({ data: ref, width, height }: Matrix): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < height; x++) {\n    for (let y = 0; y < width; y++) {\n      data[x * width + y] = ref[(height - 1 - x) * width + y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\n/**\n * Concatenates 2 matrices of the same height horizontally.\n *\n * @example\n * 1 2   3 4  becomes:  1 2 3 4\n * 5 6   7 8            5 6 7 8\n *\n * @method concatHorizontal\n * @param {Matrix} A - The first matrix\n * @param {Matrix} B - The second matrix\n * @returns {Matrix} out - The combined matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction concatHorizontal(A: Matrix, B: Matrix): Matrix {\n  const width = A.width + B.width\n  const data = new Array(A.height * width)\n\n  for (let x = 0; x < A.height; x++) {\n    for (let y = 0; y < A.width; y++) {\n      data[x * width + y] = A.data[x * A.width + y]\n    }\n    for (let y = 0; y < B.width; y++) {\n      data[x * width + y + A.width] = B.data[x * B.width + y]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height: A.height,\n  }\n}\n\n/**\n * Concatenates 2 matrices of the same height vertically.\n *\n * @example\n * 1 2   3 4  becomes:  1 2\n * 5 6   7 8            5 6\n *                      3 4\n *                      7 8\n *\n * @method concatVertical\n * @param {Matrix} A - The first matrix\n * @param {Matrix} B - The second matrix\n * @returns {Matrix} out - The combined matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction concatVertical(A: Matrix, B: Matrix): Matrix {\n  return {\n    data: A.data.concat(B.data),\n    height: A.height + B.height,\n    width: A.width,\n  }\n}\n\n/**\n * Adds 2 * `pad` cells to a matrix horizontally. The values used are mirrored from the input\n * matrix.\n *\n * @example\n * with padding 1:\n * 1 2 3 4   becomes:  1 1 2 3 4 4\n * 5 6 7 8             5 5 6 7 8 8\n *\n * With padding 2:\n * 1 2 3 4   becomes:  2 1 1 2 3 4 4 3\n * 5 6 7 8             6 5 5 6 7 8 8 7\n *\n * @method padHorizontal\n * @param {Matrix} A - The input matrix\n * @param {Number} pad - The nummber of cells to add to each side (left / right)\n * @returns {Matrix} B - The padded matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction padHorizontal(A: Matrix, pad: number): Matrix {\n  const width = A.width + 2 * pad\n  const data = new Array(width * A.height)\n  const mirrored = concatHorizontal(A, mirrorHorizonal(A))\n\n  for (let x = 0; x < A.height; x++) {\n    for (let y = -pad; y < A.width + pad; y++) {\n      data[x * width + y + pad] =\n        mirrored.data[x * mirrored.width + mod(y, mirrored.width)]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height: A.height,\n  }\n}\n\n/**\n * Adds 2 * `pad` cells to a matrix vertically. The values used are mirrored from the input\n * matrix.\n *\n * @example\n * with padding 1:\n * 1 2 3 4   becomes:  1 2 3 4\n * 5 6 7 8             1 2 3 4\n *                     5 6 7 8\n *                     5 6 7 8\n * With padding 2:\n * 1 2 3 4   becomes:  5 6 7 8\n * 5 6 7 8             1 2 3 4\n *                     1 2 3 4\n *                     5 6 7 8\n *                     5 6 7 8\n *                     1 2 3 4\n *\n * @method padVertical\n * @param {Matrix} A - The input matrix\n * @param {Number} pad - The nummber of cells to add to each side (top / bottom)\n * @returns {Matrix} B - The padded matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction padVertical(A: Matrix, pad: number): Matrix {\n  const mirrored = concatVertical(A, mirrorVertical(A))\n  const height = A.height + pad * 2\n  const data = new Array(A.width * height)\n\n  for (let x = -pad; x < A.height + pad; x++) {\n    for (let y = 0; y < A.width; y++) {\n      data[(x + pad) * A.width + y] =\n        mirrored.data[mod(x, mirrored.height) * A.width + y]\n    }\n  }\n\n  return {\n    data,\n    width: A.width,\n    height,\n  }\n}\n\n/**\n * Implements `padarray` matching Matlab only for the case where:\n *\n * `padHeight <= A.height && padWidth <= A.width`\n *\n * For an input Matrix `E`, we add padding A, B, C, D, F, G, H and I of size `padHeight` and\n * `padWidth` where appropriate. For instance, given E:\n *\n * 1 2 3\n * 4 5 6\n *\n * Placed in a padding matrix like this:\n *\n * | A | B | C |\n * |---|---|---|\n * | D | E | F |\n * |---|---|---|\n * | G | H | I |\n *\n * with padding [1, 1] it becomes:\n *\n * | 1 | 1 2 3 | 3 |\n * |---|-------|---|\n * | 1 | 1 2 3 | 3 |\n * | 4 | 4 5 6 | 6 |\n * |---|-------|---|\n * | 4 | 4 5 6 | 6 |\n *\n * with padding [2, 3] it becomes:\n *\n * | 6 5 4 | 4 5 6 | 6 5 4 |\n * | 3 2 1 | 1 2 3 | 3 2 1 |\n * |-------|-------|-------|\n * | 3 2 1 | 1 2 3 | 3 2 1 |\n * | 6 5 4 | 4 5 6 | 6 5 4 |\n * |-------|-------|-------|\n * | 6 5 4 | 4 5 6 | 6 5 4 |\n * | 3 2 1 | 1 2 3 | 3 2 1 |\n *\n * @method fastPadding\n * @param {Matrix} A - The input matrix\n * @param {Array<number>} padding - An array where the first element is the padding to apply to each\n * side on each row and the second one is the vertical padding for each side of each column\n * @returns {Matrix} B - The padded matrix\n * @private\n * @memberOf matlab\n * @since 0.0.4\n */\nfunction fastPadding(\n  A: Matrix,\n  [padHeight, padWidth]: [number, number]\n): Matrix {\n  const width = A.width + padWidth * 2\n  const height = A.height + padHeight * 2\n  const data = new Array(width * height)\n\n  for (let x = -padHeight; x < 0; x++) {\n    // A\n    for (let y = -padWidth; y < 0; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(Math.abs(x) - 1) * A.width + Math.abs(y) - 1]\n    }\n    // B\n    for (let y = 0; y < A.width; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(Math.abs(x) - 1) * A.width + y]\n    }\n    // C\n    for (let y = A.width; y < A.width + padWidth; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(Math.abs(x) - 1) * A.width + 2 * A.width - y - 1]\n    }\n  }\n\n  for (let x = 0; x < A.height; x++) {\n    // D\n    for (let y = -padWidth; y < 0; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[x * A.width + Math.abs(y) - 1]\n    }\n    // E\n    for (let y = 0; y < A.width; y++) {\n      data[(x + padHeight) * width + y + padWidth] = A.data[x * A.width + y]\n    }\n    // F\n    for (let y = A.width; y < A.width + padWidth; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[x * A.width + 2 * A.width - y - 1]\n    }\n  }\n\n  for (let x = A.height; x < A.height + padHeight; x++) {\n    // G\n    for (let y = -padWidth; y < 0; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(2 * A.height - x - 1) * A.width + Math.abs(y) - 1]\n    }\n    // H\n    for (let y = 0; y < A.width; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(2 * A.height - x - 1) * A.width + y]\n    }\n    // I\n    for (let y = A.width; y < A.width + padWidth; y++) {\n      data[(x + padHeight) * width + y + padWidth] =\n        A.data[(2 * A.height - x - 1) * A.width + 2 * A.width - y - 1]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n\nexport type PaddingValue = 'symmetric'\nexport type PaddingDirection = 'both'\n/**\n * `B = padarray(A,padsize)` pads array `A`. padsize is a vector of nonnegative integers that\n * specifies both, the amount of padding to add and the dimension along which to add it. The value\n * of an element in the vector specifies the amount of padding to add. The order of the element in\n * the vector specifies the dimension along which to add the padding.\n *\n * For example, a padsize value of `[2 3]` means add 2 elements of padding along the first dimension\n * and 3 elements of padding along the second dimension.\n *\n * By default, paddarray adds padding before the first element and after the last element along the\n * specified dimension.\n *\n * `B = padarray(A,padsize,padval)` pads array `A` where `padval` specifies the value to use as the\n * pad value. `padval` can only be 'symmetric' for this implementation of `padarray` which will pad\n * the array with mirror reflections of itself.\n *\n * This method mimics Matlab's `padarray` method with `padval = 'symmetric'` and\n * `direction = 'both'`. No other options have been implemented and, if set, they will be ignored.\n *\n * This method has been unfolded for performance and switched to simple for loops. Readability\n * suffers.\n *\n * @method padarray\n * @param {Matrix} A - The target matrix\n * @param {Array<number>} padding - An array where the first element is the padding to apply to\n * each side on each row and the second one is the vertical padding for each side of each column\n * @param {String} [padval='symmetric'] - The type of padding to apply (coerced to 'symmetric')\n * @param {String} [direction='both'] - The direction to which apply padding (coerced to 'both')\n * @returns {Matrix} c - An array with padding added on each side.\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function padarray(\n  A: Matrix,\n  [padHeight, padWidth]: [number, number],\n  _padval?: PaddingValue,\n  _direction?: PaddingDirection\n): Matrix {\n  // If the padding to mirror is not greater than `A` dimensions, we can use `fastPadding`,\n  // otherwise we fall back to a slower implementation that mimics Matlab behavior for longer\n  // matrices\n  if (A.height >= padHeight && A.width >= padWidth) {\n    return fastPadding(A, [padHeight, padWidth])\n  }\n\n  return padVertical(padHorizontal(A, padWidth), padHeight)\n}\n","/**\n * SSIM External API\n *\n * @module main\n */\nimport { rgb2gray } from './matlab'\nimport { mean2d } from './math'\nimport { ssim as fastSsim } from './ssim'\nimport { originalSsim } from './originalSsim'\nimport { bezkrovnySsim } from './bezkrovnySsim'\nimport { downsample } from './downsample'\nimport { defaults } from './defaults'\nimport { Options, Images, Matrices, Matrix, MSSIMMatrix } from './types'\nimport { weberSsim } from './weberSsim'\n\nexport { Options, Matrix }\n\nconst ssimTargets = {\n  fast: fastSsim,\n  original: originalSsim,\n  bezkrovny: bezkrovnySsim,\n  weber: weberSsim,\n}\n\nfunction validateOptions(options: Options) {\n  Object.keys(options).forEach((option) => {\n    if (!(option in defaults)) {\n      throw new Error(`\"${option}\" is not a valid option`)\n    }\n  })\n  if ('k1' in options && (typeof options.k1 !== 'number' || options.k1 < 0)) {\n    throw new Error(`Invalid k1 value. Default is ${defaults.k1}`)\n  }\n  if ('k2' in options && (typeof options.k2 !== 'number' || options.k2 < 0)) {\n    throw new Error(`Invalid k2 value. Default is ${defaults.k2}`)\n  }\n  if (!(options.ssim in ssimTargets)) {\n    throw new Error(\n      `Invalid ssim option (use: ${Object.keys(ssimTargets).join(', ')})`\n    )\n  }\n}\n\nexport function getOptions(userOptions?: Partial<Options>): Options {\n  const options = { ...defaults, ...userOptions }\n\n  validateOptions(options)\n\n  return options\n}\n\nfunction validateDimensions([pixels1, pixels2, options]: Images): Images {\n  if (pixels1.width !== pixels2.width || pixels1.height !== pixels2.height) {\n    throw new Error('Image dimensions do not match')\n  }\n\n  return [pixels1, pixels2, options]\n}\n\nfunction toGrayScale([pixels1, pixels2, options]: Images): Matrices {\n  return [rgb2gray(pixels1), rgb2gray(pixels2), options]\n}\n\nfunction toResize([pixels1, pixels2, options]: Matrices): Matrices {\n  const pixels = downsample([pixels1, pixels2], options)\n\n  return [pixels[0], pixels[1], options]\n}\n\nfunction comparison([pixels1, pixels2, options]: Matrices): Matrix {\n  return ssimTargets[options.ssim](pixels1, pixels2, options)\n}\n\n/**\n * @method ssim - The ssim method. You can call the package directly or through the `ssim` property.\n * @public\n * @example import mod = from 'ssim.js';\n * mod(imgBuffer1, imgBuffer2);\n * mod.ssim(imgBuffer1, imgBuffer2);\n */\nexport function ssim(\n  image1: ImageData,\n  image2: ImageData,\n  userOptions?: Partial<Options>\n): {\n  ssim_map: Matrix\n  mssim: number\n  performance: number\n} {\n  const start = new Date().getTime()\n  const options = getOptions(userOptions)\n  const ssimMap = comparison(\n    toResize(toGrayScale(validateDimensions([image1, image2, options])))\n  )\n  const mssim =\n    (ssimMap as MSSIMMatrix).mssim !== undefined\n      ? (ssimMap as MSSIMMatrix).mssim\n      : mean2d(ssimMap)\n  return {\n    mssim,\n    ssim_map: ssimMap,\n    performance: new Date().getTime() - start,\n  }\n}\n\nexport default ssim\n","import { Matrix } from '../types'\nimport { sum2d, divide2d } from '../math'\n\n/**\n * Creates a matrix of lenght `2 * length + 1` with values being the sum of the square of the\n * distance for each component from the center. E.g:\n *\n * For a length of 5 it results in a matrix size of 11. Looking at [0, 0] (distance: [-5, -5] from\n * the center), the value at that position becomes `-5^2 + -5^2 = 50`\n *\n * @method rangeSquare2d\n * @param {Number} length - The maxium distance from the matrix center\n * @returns {Matrix} mx - The generated matrix\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction rangeSquare2d(length: number): Matrix {\n  const size = length * 2 + 1\n  const data = new Array(size ** 2)\n\n  for (let x = 0; x < size; x++) {\n    for (let y = 0; y < size; y++) {\n      data[x * size + y] = (x - length) ** 2 + (y - length) ** 2\n    }\n  }\n\n  return {\n    data,\n    width: size,\n    height: size,\n  }\n}\n\n/**\n * Applies a gaussian filter of sigma to a given matrix\n *\n * @method gaussianFilter2d\n * @param {Matrix} A - The input matrix\n * @param {Number} σ - The sigma value\n * @returns {Matrix} B - The matrix with the gaussian filter applied\n * @private\n * @memberOf matlab\n * @since 0.0.2\n */\nfunction gaussianFilter2d(\n  { data: ref, width, height }: Matrix,\n  σ: number\n): Matrix {\n  const data = new Array(ref.length)\n\n  for (let x = 0; x < ref.length; x++) {\n    data[x] = Math.exp(-ref[x] / (2 * σ ** 2))\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n/**\n * Create predefined 2-D filter\n *\n * `h = fspecial(type, parameters)` accepts the filter specified by type plus additional modifying\n * parameters particular to the type of filter chosen. If you omit these arguments, fspecial uses\n * default values for the parameters.\n *\n * This method mimics Matlab's `fspecial2` method with `type = 'gaussian'`. `hsize` cannot be a\n * vector (unlike Matlab's implementation), only a Number is accepted.\n *\n * `h = fspecial('gaussian', hsize, sigma)` returns a rotationally symmetric Gaussian lowpass filter\n * of size `hsize` with standard deviation sigma (positive). In this implementation `hsize` will\n * always be a scalar, which will result in `h` being a square matrix.\n *\n * The gaussian logic follows: hg(hsize) = e^(-2*hsize^2 / 2σ^2)\n *\n * @example\n *   fspecial('gaussian', 3, 1.5) === {\n *     data: [\n *       0.094742, 0.118318, 0.094742,\n *       0.118318, 0.147761, 0.118318,\n *       0.094742, 0.118318, 0.094742\n *     ],\n *     width: 3,\n *     height: 3\n *   };\n *\n * @method fspecial\n * @param {String} [type='gaussian'] - The type of 2D filter to create (coerced to 'gaussian')\n * @param {Number} [hsize=3] - The length of the filter\n * @param {Number} [σ=1.5] - The filter sigma value\n * @returns {Matrix} c - Returns the central part of the convolution of the same\n * size as `a`.\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function fspecial(_type?: 'gaussian', hsize = 3, σ = 1.5): Matrix {\n  hsize = (hsize - 1) / 2\n\n  const pos = rangeSquare2d(hsize)\n  const gauss = gaussianFilter2d(pos, σ)\n  const total = sum2d(gauss)\n\n  return divide2d(gauss, total)\n}\n","import { mod } from './mod'\nimport { padarray, PaddingValue } from './padarray'\nimport { floor } from '../math'\nimport { filter2 } from './filter2'\nimport { Matrix, Shape } from '../types'\n\n/**\n * Adds padding to input matrix A\n *\n * @method padMatrix\n * @param {Matrix} A - The target matrix\n * @param {Number} frows - The number of rows in the filter\n * @param {Number} fcols - The number of columns in the filter\n * @param {String} pad - The type of padding to apply\n * @param {Matrix} B - The padded input matrix\n * @private\n * @memberOf matlab\n */\nfunction padMatrix(\n  A: Matrix,\n  frows: number,\n  fcols: number,\n  pad: PaddingValue\n): Matrix {\n  A = padarray(A, floor([frows / 2, fcols / 2]) as [number, number], pad)\n  if (mod(frows, 2) === 0) {\n    // remove the last row\n    A.data = A.data.slice(0, -A.width)\n    A.height--\n  }\n  if (mod(fcols, 2) === 0) {\n    // remove the last column\n    const data = []\n\n    for (let x = 0; x < A.data.length; x++) {\n      if ((x + 1) % A.width !== 0) {\n        data.push(A.data[x])\n      }\n    }\n    A.data = data\n    A.width--\n  }\n  return A\n}\n\n/**\n * Gets the `shape` parameter for `conv2` based on the `resSize` parameter for `imfilter`. In most\n * cases they are equivalent except for when `resSize` equals \"same\" which is converted to \"valid\".\n *\n * @method getConv2Size\n * @param {String} resSize - The format to use for the `imfilter` call\n * @returns {String} shape - The shape value to use for `conv2`\n * @private\n * @memberOf matlab\n */\nfunction getConv2Size(resSize: Shape): Shape {\n  if (resSize === 'same') {\n    resSize = 'valid'\n  }\n  return resSize\n}\n\n/**\n * `B = imfilter(A,f)` filters a 2-dimensional array `A` with the 2-dimensional filter `f`. The\n * result `B` has the same size as `A`.\n *\n * `imfilter` computes each element of the output, `B`. If `A` is an integer, `imfilter` will not\n * truncate the output elements that exceed the range, and it will not round fractional values.\n *\n * This method mimics Matlab's `imfilter` method with `padval = 'symmetric'` without integer\n * rounding. No other options have been implemented and, if set, they will be ignored.\n *\n * @method imfilter\n * @param {Matrix} A - The target matrix\n * @param {Matrix} f - The filter to apply\n * @param {String} [pad=\"symmetric\"] - The type of padding. Only \"symmetric\" is implemented\n * @param {String} [resSize=\"same\"] - The format to use for the filter size. Valid values are:\n * \"same\", \"valid\" and \"full\"\n * @returns {Matrix} B - The filtered array\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function imfilter(\n  A: Matrix,\n  f: Matrix,\n  pad: PaddingValue = 'symmetric',\n  resSize: Shape = 'same'\n) {\n  A = padMatrix(A, f.width, f.height, pad)\n  resSize = getConv2Size(resSize)\n  return filter2(f, A, resSize)\n}\n","import { Matrix } from '../types'\n\n/**\n * `Y = normpdf(X,μ,σ)` computes the pdf at each of the values in `X` using the normal\n * distribution with mean `μ` and standard deviation `σ`. `X`, `μ`, and `σ` can be vectors,\n * matrices, or multidimensional arrays that all have the same size. A scalar input is expanded to a\n * constant array with the same dimensions as the other inputs. The parameters in `σ` must be\n * positive.\n *\n * The normal pdf is: `y = f(x|μ,σ) = (1 / (σ√(2π))) * e^(-(x-μ)^2/2σ^2)`\n *\n * The likelihood function is the pdf viewed as a function of the parameters. Maximum likelihood\n * estimators (MLEs) are the values of the parameters that maximize the likelihood function for a\n * fixed value of `x`.\n *\n * The standard normal distribution has `µ = 0` and `σ = 1`.\n * If x is standard normal, then `xσ + µ` is also normal with mean `µ` and standard deviation `σ`.\n * Conversely, if `y` is normal with mean `µ` and standard deviation `σ`, then `x = (y – µ) / σ` is\n * standard normal.\n *\n * `Y = normpdf(X)` uses the standard normal distribution (`µ = 0`, `σ = 1`).\n * `Y = normpdf(X,µ)` uses the normal distribution with unit standard deviation (`σ = 1`).\n *\n * @example normpdf({ data: [2, 1, 0, 1, 2], width: 5, height: 1 }, 0, 1.5) =>\n *   { data: [ 0.10934, 0.21297, 0.26596, 0.21297, 0.10934], width: 5, height: 1 }\n *\n * @method normpdf\n * @param {Matrix} X - The input matrix\n * @param {Number} [µ=0] - The length of the filter\n * @param {Number} [σ=1] - The filter sigma value\n * @returns {Matrix} Y - Returns the central part of the convolution of the same\n * size as `a`.\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function normpdf(\n  { data: ref, width, height }: Matrix,\n  µ = 0,\n  σ = 1\n): Matrix {\n  // data = ((2 * pi)^(-1 / 2)) * exp(-((x - µ) / σ)^2 / 2) / σ;\n  const SQ2PI = 2.506628274631000502415765284811\n  const data = new Array(ref.length)\n\n  for (let i = 0; i < ref.length; i++) {\n    const z = (ref[i] - µ) / σ\n\n    data[i] = Math.exp(-(z ** 2) / 2) / (σ * SQ2PI)\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\n\n/**\n * Converts an imageData object of { width, height, data } into a 2d matrix [row, column]\n * where the value is the grayscale equivalent of the rgb input.\n *\n * This method mimics Matlab's `rgb2gray` method\n *\n * @method rgb2gray\n * @param {Matrix | ImageData} imageData - The input imageData\n * @returns {Object} grayscale - A grayscale representation of the input image\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function rgb2gray({\n  data: d,\n  width,\n  height,\n}: Matrix | ImageData): Matrix {\n  const uint8Array = new Uint8Array(width * height)\n  for (let i = 0; i < d.length; i += 4) {\n    const grayIndex = i / 4\n    /**\n     * These values are not derived from ITU's recommendation of: [0.2126,\n     * 0.7152, 0.0722] for [r, g, b] but on Matlab's implementation of [0.2989,\n     * 0.5870, 0.1140]\n     *\n     * Note that values are rounded to ensure an exact match with the original\n     * results. Rounding them would NOT lead to higher accuracy since the exact\n     * values for RGB to grayscale conversion are somewhat arbitrary (as shown\n     * by the differences between ITU and Matlab).\n     *\n     * ± 0.5 pixel differences won't be perceptible for the human eye and will\n     * have a small impact on SSIM. Based on some sample data changes were of\n     * the order of 10^-3.\n     */\n    uint8Array[grayIndex] =\n      0.29894 * d[i] + 0.58704 * d[i + 1] + 0.11402 * d[i + 2] + 0.5\n  }\n  return {\n    data: Array.from(uint8Array),\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\n\n/**\n * Generates a matrix based on input `mx` but excluding items based on their modulo and their\n * position in the original matrix.\n *\n * It's a crude implementation of Matlab's `A(1:f:end,1:f:end)` syntax where the first parameter\n * is the matrix, the next one is an array describing the rows to skip [start position, every `f`\n * elements an end position] and the last one follows the same syntax for columns.\n *\n * @example\n * ```\n * img1(1:f:end,1:f:end)\n *\n * ```\n *\n * becomes:\n *\n * ```\n * skip2d(img1, [0, f, img1.length], [0, f, img1[0].length])\n * ```\n *\n * Note that the start index is 0 since, unlike Matlab's, arrays start at 0. Also, unlike in Matlab,\n * `f` must be an integer greater than or equal to 1.\n *\n * @method skip2d\n * @param {Matrix} A - The input matrix\n * @param {Array<number>} - start row, every row, end row\n * @param {Array<number>} - start col, every col, end col\n * @returns {Matrix} B - The downsized matrix\n * @public\n * @memberOf matlab\n * @since 0.0.2\n */\nexport function skip2d(\n  A: Matrix,\n  [startRow, everyRow, endRow]: [number, number, number],\n  [startCol, everyCol, endCol]: [number, number, number]\n): Matrix {\n  const width = Math.ceil((endCol - startCol) / everyCol)\n  const height = Math.ceil((endRow - startRow) / everyRow)\n  const data = new Array(width * height)\n\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      const Ai = startRow + i * everyRow\n      const Aj = startCol + j * everyCol\n\n      data[i * width + j] = A.data[Ai * A.width + Aj]\n    }\n  }\n\n  return {\n    data,\n    width,\n    height,\n  }\n}\n","import { Matrix } from '../types'\n\n/**\n * Transposes a vector or a matrix\n *\n * This method mimics Matlab's `transpose` method (which equals to the `A.'` syntax)\n *\n * `B = A.'` returns the nonconjugate transpose of A, that is, interchanges the row and column index\n * for each element.\n *\n * This method does not handle complex or imaginary numbers\n *\n * @method transpose\n * @param {Matrix} A - The matrix to transpose\n * @returns {Matrix} B - The transposed matrix\n * @public\n * @memberOf matlab\n */\nexport function transpose({ data: ref, width, height }: Matrix): Matrix {\n  const data = new Array(width * height)\n\n  for (let i = 0; i < height; i++) {\n    for (let j = 0; j < width; j++) {\n      data[j * height + i] = ref[i * width + j]\n    }\n  }\n\n  return {\n    data,\n    height: width,\n    width: height,\n  }\n}\n","/**\n * Implements all ssim-specific logic.\n *\n * Reproduces the original SSIM matlab scripts. For a direct comparison you may want to check the\n * scripts contained within `/assets`\n *\n * @namespace ssim\n */\nimport {\n  add2d,\n  divide2d,\n  multiply2d,\n  square2d,\n  subtract2d,\n  sum2d,\n} from './math'\nimport { conv2, normpdf, transpose } from './matlab'\nimport { Options, Matrix } from './types'\n\n/**\n * Generates a SSIM map based on two input image matrices. For images greater than 512 pixels, it\n * will downsample by default (unless `options.downsample` is set to falsy).\n *\n * Images must be a 2-Dimensional grayscale image\n *\n * This method produces the same exact output than `assets/ssim.m` when running on Matlab. It's\n * mathematically equivalent but it is not a line-by-line port. If you want a line-by-line port\n * check `originalSsim`. Several performance optimizations have been made here to achieve greater\n * performance.\n *\n * @method ssim\n * @param {Matrix} pixels1 - The reference matrix\n * @param {Matrix} pixels2 - The second matrix to compare against\n * @param {Options} options - The input options parameter\n * @returns {Matrix} ssim_map - A matrix containing the map of computed SSIMs\n * @public\n * @memberOf ssim\n */\nexport function ssim(\n  pixels1: Matrix,\n  pixels2: Matrix,\n  options: Options\n): Matrix {\n  let w = normpdf(getRange(options.windowSize), 0, 1.5)\n  const L = 2 ** options.bitDepth - 1\n  const c1 = (options.k1 * L) ** 2\n  const c2 = (options.k2 * L) ** 2\n\n  w = divide2d(w, sum2d(w))\n  const wt = transpose(w)\n  const μ1 = conv2(pixels1, w, wt, 'valid')\n  const μ2 = conv2(pixels2, w, wt, 'valid')\n  const μ1Sq = square2d(μ1)\n  const μ2Sq = square2d(μ2)\n  const μ12 = multiply2d(μ1, μ2)\n  const pixels1Sq = square2d(pixels1)\n  const pixels2Sq = square2d(pixels2)\n  const σ1Sq = subtract2d(conv2(pixels1Sq, w, wt, 'valid'), μ1Sq)\n  const σ2Sq = subtract2d(conv2(pixels2Sq, w, wt, 'valid'), μ2Sq)\n  const σ12 = subtract2d(\n    conv2(multiply2d(pixels1, pixels2), w, wt, 'valid'),\n    μ12\n  )\n\n  if (c1 > 0 && c2 > 0) {\n    return genSSIM(μ12, σ12, μ1Sq, μ2Sq, σ1Sq, σ2Sq, c1, c2)\n  }\n  return genUQI(μ12, σ12, μ1Sq, μ2Sq, σ1Sq, σ2Sq)\n}\n\n/**\n * Generates a range of distances of size `2n+1` with increments of 1 and centered at 0.\n *\n * @example `getRange(2) => [2 1 0 1 2]\n * @method getRange\n * @param {Number} size - The maximum distance from the center\n * @returns {Matrix} out - The generated vector\n * @private\n * @memberOf ssim\n */\nfunction getRange(size: number): Matrix {\n  const offset = Math.floor(size / 2)\n  const data = new Array(offset * 2 + 1)\n\n  for (let x = -offset; x <= offset; x++) {\n    data[x + offset] = Math.abs(x)\n  }\n\n  return {\n    data,\n    width: data.length,\n    height: 1,\n  }\n}\n\n/**\n * Generates the ssim_map based on the intermediate values of the convolutions of the input with the\n * gaussian filter.\n *\n * These methods apply when K1 or K2 are not 0 (non UQI)\n *\n * @method genSSIM\n * @param {Matrix} μ12 - The cell-by cell multiplication of both images convolved\n * with the gaussian filter\n * @param {Matrix} σ12 - The convolution of cell-by cell multiplication of both\n * images minus μ12\n * @param {Matrix} μ1Sq - The convolution of image1 with the gaussian filter squared\n * @param {Matrix} μ2Sq - The convolution of image2 with the gaussian filter squared\n * @param {Matrix} σ1Sq - The convolution of image1^2, minus μ1Sq\n * @param {Matrix} σ2Sq - The convolution of image2^2, minus μ2Sq\n * @param {Number} c1 - The first stability constant\n * @param {Number} c2 - The second stability constant\n * @returns {Matrix} ssim_map - The generated map of SSIM values at each window\n * @private\n * @memberOf ssim\n */\nfunction genSSIM(\n  μ12: Matrix,\n  σ12: Matrix,\n  μ1Sq: Matrix,\n  μ2Sq: Matrix,\n  σ1Sq: Matrix,\n  σ2Sq: Matrix,\n  c1: number,\n  c2: number\n): Matrix {\n  const num1 = add2d(multiply2d(μ12, 2), c1)\n  const num2 = add2d(multiply2d(σ12, 2), c2)\n  const denom1 = add2d(add2d(μ1Sq, μ2Sq), c1)\n  const denom2 = add2d(add2d(σ1Sq, σ2Sq), c2)\n\n  return divide2d(multiply2d(num1, num2), multiply2d(denom1, denom2))\n}\n\n/**\n * Generates the Universal Quality Index (UQI) ssim_map based on the intermediate values of the\n * convolutions of the input with the gaussian filter.\n *\n * These methods apply when K1 or K2 are 0 (UQI)\n *\n * @method genUQI\n * @param {Matrix} μ12 - The cell-by cell multiplication of both images convolved\n * with the gaussian filter\n * @param {Matrix} σ12 - The convolution of cell-by cell multiplication of both\n * images minus μ12\n * @param {Matrix} μ1Sq - The convolution of image1 with the gaussian filter squared\n * @param {Matrix} μ2Sq - The convolution of image2 with the gaussian filter squared\n * @param {Matrix} σ1Sq - The convolution of image1^2, minus μ1Sq\n * @param {Matrix} σ2Sq - The convolution of image2^2, minus μ2Sq\n * @returns {Matrix} ssim_map - The generated map of SSIM values at each window\n * @private\n * @memberOf ssim\n */\nfunction genUQI(\n  μ12: Matrix,\n  σ12: Matrix,\n  μ1Sq: Matrix,\n  μ2Sq: Matrix,\n  σ1Sq: Matrix,\n  σ2Sq: Matrix\n): Matrix {\n  const numerator1 = multiply2d(μ12, 2)\n  const numerator2 = multiply2d(σ12, 2)\n  const denominator1 = add2d(μ1Sq, μ2Sq)\n  const denominator2 = add2d(σ1Sq, σ2Sq)\n\n  return divide2d(\n    multiply2d(numerator1, numerator2),\n    multiply2d(denominator1, denominator2)\n  )\n}\n","/* eslint-disable max-statements */\n// Exceeding max-statements to preserve the structure of the original Matlab script\nimport {\n  add2d,\n  divide2d,\n  multiply2d,\n  square2d,\n  subtract2d,\n  sum2d,\n} from './math'\nimport { filter2, fspecial } from './matlab'\nimport { Options, Matrix } from './types'\n\n/**\n * Generates a SSIM map based on two input image matrices. For images greater than 512 pixels, it\n * will downsample them.\n *\n * Images must be a 2-Dimensional grayscale image\n *\n * This method is a line-by-line port of `assets/ssim.m`. Some operations are more verbose here\n * since more logic is needed in JS to manipulate matrices than in Matlab\n *\n * Note that setting `options1.k1` and `options.k2` to 0 will generate the UQI (Universal Quality\n * Index), since it's a special case of SSIM. In general that's undesierable since `k1` and `k2`\n * contribute to the stabilization coeficients `c1` and `c2`.\n *\n * For a mathematically equivalent and more efficient implementation check `./ssim.js`.\n *\n * @method originalSsim\n * @param {Matrix} pixels1 - The reference matrix\n * @param {Matrix} pixels2 - The second matrix to compare against\n * @param {Object} options - The input options parameter\n * @returns {Matrix} ssim_map - A matrix containing the map of computed SSIMs\n * @public\n * @memberOf ssim\n * @since 0.0.2\n */\nexport function originalSsim(\n  pixels1: Matrix,\n  pixels2: Matrix,\n  options: Options\n): Matrix {\n  let w = fspecial('gaussian', options.windowSize, 1.5)\n  const L = 2 ** options.bitDepth - 1\n  const c1 = (options.k1 * L) ** 2\n  const c2 = (options.k2 * L) ** 2\n\n  w = divide2d(w, sum2d(w))\n\n  const μ1 = filter2(w, pixels1, 'valid')\n  const μ2 = filter2(w, pixels2, 'valid')\n  const μ1Sq = square2d(μ1)\n  const μ2Sq = square2d(μ2)\n  const μ12 = multiply2d(μ1, μ2)\n  const pixels1Sq = square2d(pixels1)\n  const pixels2Sq = square2d(pixels2)\n  const σ1Sq = subtract2d(filter2(w, pixels1Sq, 'valid'), μ1Sq)\n  const σ2Sq = subtract2d(filter2(w, pixels2Sq, 'valid'), μ2Sq)\n  const σ12 = subtract2d(filter2(w, multiply2d(pixels1, pixels2), 'valid'), μ12)\n\n  if (c1 > 0 && c2 > 0) {\n    const num1 = add2d(multiply2d(μ12, 2), c1)\n    const num2 = add2d(multiply2d(σ12, 2), c2)\n    const denom1 = add2d(add2d(μ1Sq, μ2Sq), c1)\n    const denom2 = add2d(add2d(σ1Sq, σ2Sq), c2)\n\n    return divide2d(multiply2d(num1, num2), multiply2d(denom1, denom2))\n  }\n\n  const numerator1 = multiply2d(μ12, 2)\n  const numerator2 = multiply2d(σ12, 2)\n  const denominator1 = add2d(μ1Sq, μ2Sq)\n  const denominator2 = add2d(σ1Sq, σ2Sq)\n\n  return divide2d(\n    multiply2d(numerator1, numerator2),\n    multiply2d(denominator1, denominator2)\n  )\n}\n","/**\n * Implements Bezkrovny's ssim-specific logic.\n *\n * Refactor of the TypeScript SSIM implementation by Bezkrovny, modified to match the api of ssim.js\n * and reduce duplication.\n *\n * The original work is available at: https://github.com/igor-bezkrovny/image-quantization which is\n * itself a port of the Java SSIM implementation available at https://github.com/rhys-e/structural-similarity\n * both under MIT license\n *\n * @namespace bezkrovnySsim\n */\nimport { average, variance, covariance } from './math'\nimport { sub } from './matlab'\nimport { Options, Matrix } from './types'\n\n/**\n * Generates a SSIM map based on two input image matrices.\n *\n * Images must be a 2-Dimensional grayscale image\n *\n * This method produces a simliar output to `assets/ssim.m` (~1%) when running on Matlab. It's based\n * of Igor Bezkrovny's TypeScript implementation\n *\n * @method bezkrovnySsim\n * @param {Matrix} pixels1 - The reference matrix\n * @param {Matrix} pixels2 - The second matrix to compare against\n * @param {Options} options - The input options parameter\n * @returns {Matrix} ssim_map - A matrix containing the map of computed SSIMs\n * @public\n * @memberOf bezkrovnySsim\n */\nexport function bezkrovnySsim(\n  pixels1: Matrix,\n  pixels2: Matrix,\n  options: Options\n) {\n  const { windowSize } = options\n  const width = Math.ceil(pixels1.width / windowSize)\n  const height = Math.ceil(pixels1.height / windowSize)\n  const data = new Array(width * height)\n  let counter = 0\n\n  for (let y = 0; y < pixels1.height; y += windowSize) {\n    for (let x = 0; x < pixels1.width; x += windowSize) {\n      const windowWidth = Math.min(windowSize, pixels1.width - x)\n      const windowHeight = Math.min(windowSize, pixels1.height - y)\n\n      const values1 = sub(pixels1, x, windowHeight, y, windowWidth)\n      const values2 = sub(pixels2, x, windowHeight, y, windowWidth)\n\n      data[counter++] = windowSsim(values1, values2, options)\n    }\n  }\n  return { data, width, height }\n}\n\n/**\n * Generates the per-window ssim value\n *\n * @method windowSsim\n * @param {Matrix} values1 - The matrix of the ssim window to compute for image 1\n * @param {Matrix} values2 - The matrix of the ssim window to compute for image 2\n * @param {Options} options - The input options parameter\n * @returns {Number} ssim - The ssim value at the current window\n * @private\n * @memberOf bezkrovnySsim\n */\nfunction windowSsim(\n  { data: values1 }: Matrix,\n  { data: values2 }: Matrix,\n  { bitDepth, k1, k2 }: Options\n): number {\n  const L = 2 ** bitDepth - 1\n  const c1 = (k1 * L) ** 2\n  const c2 = (k2 * L) ** 2\n  const average1 = average(values1)\n  const average2 = average(values2)\n  const σSqx = variance(values1, average1)\n  const σSqy = variance(values2, average2)\n  const σxy = covariance(values1, values2, average1, average2)\n\n  const numerator = (2 * average1 * average2 + c1) * (2 * σxy + c2)\n  const denom1 = average1 ** 2 + average2 ** 2 + c1\n  const denom2 = σSqx + σSqy + c2\n\n  return numerator / (denom1 * denom2)\n}\n","/**\n * Implements downsampling logic\n *\n * @namespace downsample\n */\nimport { divide2d, sum2d } from './math'\nimport { imfilter, ones, skip2d } from './matlab'\nimport { Matrix, Options } from './types'\n\n/**\n * For a given 2D filter `filter`, downsize image `pixels` by a factor of `f`.\n *\n * @method imageDownsample\n * @param {Matrix} pixels - The matrix to downsample\n * @param {Matrix} filter - The filter to convolve the image with\n * @param {number} f - The downsampling factor (`image size / f`)\n * @returns {Matrix} imdown - The downsampled, filtered image\n * @private\n * @memberOf downsample\n */\nfunction imageDownsample(pixels: Matrix, filter: Matrix, f: number): Matrix {\n  const imdown = imfilter(pixels, filter, 'symmetric', 'same')\n\n  return skip2d(imdown, [0, f, imdown.height], [0, f, imdown.width])\n}\n\n/**\n * Downsamples images greater than `maxSize` pixels on the smallest direction. If neither image\n * exceeds these dimensions they are returned as they are.\n *\n * It replicates the same logic than the original matlab scripts\n *\n * @method originalDownsample\n * @param {Matrix} pixels1 - The first matrix to downsample\n * @param {Matrix} pixels2 - The second matrix to downsample\n * @param {number} [maxSize=256] - The maximum size on the smallest dimension\n * @returns {[Matrix, Matrix]} ssim_map - A matrix containing the map of computed SSIMs\n * @private\n * @memberOf downsample\n */\nfunction originalDownsample(\n  pixels1: Matrix,\n  pixels2: Matrix,\n  maxSize = 256\n): [Matrix, Matrix] {\n  const factor = Math.min(pixels1.width, pixels2.height) / maxSize\n  const f = Math.round(factor)\n\n  if (f > 1) {\n    let lpf = ones(f)\n\n    lpf = divide2d(lpf, sum2d(lpf))\n\n    pixels1 = imageDownsample(pixels1, lpf, f)\n    pixels2 = imageDownsample(pixels2, lpf, f)\n  }\n\n  return [pixels1, pixels2]\n}\n\n/**\n * Determines the downsizing algorithm to implement (if any) to the reference and target images\n *\n * @method downsample\n * @param {[Matrix, Matrix]} pixels - The first and second matrices to downsample\n * @param {Object} options - The inputs options object\n * @returns {[Matrix, Matrix]} pixels - An array containing the 2 downsized images\n * @public\n * @memberOf downsample\n */\nexport function downsample(\n  pixels: [Matrix, Matrix],\n  options: Options\n): [Matrix, Matrix] {\n  if (options.downsample === 'original') {\n    return originalDownsample(pixels[0], pixels[1], options.maxSize)\n  }\n  // else if options.downsample === 'fast' -> the image is downsampled when read (readpixels.js)\n  // else do not downsample\n  return pixels\n}\n","import { Options } from './types'\n\nexport const defaults: Options = {\n  windowSize: 11,\n  k1: 0.01,\n  k2: 0.03,\n  bitDepth: 8,\n  downsample: 'original',\n  ssim: 'weber',\n  maxSize: 256,\n}\n","/**\n * Implements Dan Weber's ssim-specific logic.\n *\n * @namespace weberSsim\n */\nimport { ImageMatrix, MSSIMMatrix, Options } from './types'\n\nfunction edgeHandler(w: number, h: number, sumArray: any, matrixWidth: number) {\n  const rightEdge = sumArray[h * matrixWidth + w + 1]\n  const bottomEdge = sumArray[(h + 1) * matrixWidth + w]\n  const bottomRightEdge = sumArray[(h + 1) * matrixWidth + w + 1]\n  return { rightEdge, bottomEdge, bottomRightEdge }\n}\n\nexport function partialSumMatrix1(\n  pixels: ImageMatrix,\n  f: (v: number, x: number, y: number) => number\n) {\n  const { width, height, data } = pixels\n  const matrixWidth = width + 1\n  const matrixHeight = height + 1\n  const sumArray = new Int32Array(matrixWidth * matrixHeight)\n  for (let h = height - 1; h >= 0; --h) {\n    for (let w = width - 1; w >= 0; --w) {\n      const { rightEdge, bottomEdge, bottomRightEdge } = edgeHandler(\n        w,\n        h,\n        sumArray,\n        matrixWidth\n      )\n\n      sumArray[h * matrixWidth + w] =\n        f(data[h * width + w], w, h) + rightEdge + bottomEdge - bottomRightEdge\n    }\n  }\n  return { data: sumArray, height: matrixHeight, width: matrixWidth }\n}\n\nexport function partialSumMatrix2(\n  pixels1: ImageMatrix,\n  pixels2: ImageMatrix,\n  f: (a: number, b: number, x: number, y: number) => number\n) {\n  const { width, height, data: data1 } = pixels1\n  const { data: data2 } = pixels2\n  const matrixWidth = width + 1\n  const matrixHeight = height + 1\n  const sumArray = new Int32Array(matrixWidth * matrixHeight)\n  for (let h = height - 1; h >= 0; --h) {\n    for (let w = width - 1; w >= 0; --w) {\n      const { rightEdge, bottomEdge, bottomRightEdge } = edgeHandler(\n        w,\n        h,\n        sumArray,\n        matrixWidth\n      )\n      const offset = h * width + w\n      sumArray[h * matrixWidth + w] =\n        f(data1[offset], data2[offset], w, h) +\n        rightEdge +\n        bottomEdge -\n        bottomRightEdge\n    }\n  }\n  return { data: sumArray, height: matrixHeight, width: matrixWidth }\n}\n\nexport function windowMatrix(\n  sumMatrix: any,\n  windowSize: number,\n  divisor: number\n) {\n  const { width: matrixWidth, height: matrixHeight, data: sumArray } = sumMatrix\n  const imageWidth = matrixWidth - 1\n  const imageHeight = matrixHeight - 1\n  const windowWidth = imageWidth - windowSize + 1\n  const windowHeight = imageHeight - windowSize + 1\n  const windows = new Int32Array(windowWidth * windowHeight)\n  for (let h = 0; h < imageHeight; ++h) {\n    for (let w = 0; w < imageWidth; ++w) {\n      if (w < windowWidth && h < windowHeight) {\n        const sum =\n          // value at (w,h)\n          sumArray[matrixWidth * h + w] -\n          // value at (w+windowSize,h) == right side\n          sumArray[matrixWidth * h + w + windowSize] -\n          // value at (w,h+windowSize) == bottom side\n          sumArray[matrixWidth * (h + windowSize) + w] +\n          // value at (w+windowSize, h+windowSize) == bottomRight corner\n          sumArray[matrixWidth * (h + windowSize) + w + windowSize]\n\n        windows[h * windowWidth + w] = sum / divisor\n      }\n    }\n  }\n  return { height: windowHeight, width: windowWidth, data: windows }\n}\n\nexport function windowSums(pixels: ImageMatrix, windowSize: number) {\n  return windowMatrix(\n    partialSumMatrix1(pixels, (a) => a),\n    windowSize,\n    1\n  )\n}\n\nexport function windowVariance(\n  pixels: ImageMatrix,\n  sums: any,\n  windowSize: number\n) {\n  const varianceCalculation = (v: number) => v * v\n  const windowSquared = windowSize * windowSize\n  const varX = windowMatrix(\n    partialSumMatrix1(pixels, varianceCalculation),\n    windowSize,\n    1\n  )\n  for (let i = 0; i < sums.data.length; ++i) {\n    const mean = sums.data[i] / windowSquared\n    const sumSquares = varX.data[i] / windowSquared\n\n    const squareMeans = mean * mean\n    varX.data[i] = 1024 * (sumSquares - squareMeans)\n  }\n  return varX\n}\n\nexport function windowCovariance(\n  pixels1: ImageMatrix,\n  pixels2: ImageMatrix,\n  sums1: any,\n  sums2: any,\n  windowSize: number\n) {\n  const covarianceCalculation = (a: number, b: number) => a * b\n  const windowSquared = windowSize * windowSize\n  const covXY = windowMatrix(\n    partialSumMatrix2(pixels1, pixels2, covarianceCalculation),\n    windowSize,\n    1\n  )\n  for (let i = 0; i < sums1.data.length; ++i) {\n    covXY.data[i] =\n      1024 *\n      (covXY.data[i] / windowSquared -\n        (sums1.data[i] / windowSquared) * (sums2.data[i] / windowSquared))\n  }\n  return covXY\n}\n\n/**\n * Generates a SSIM map based on two input image matrices.\n * Weber SSIM is an SSIM algorithm that operates in linear time by building\n * partial sum arrays of values, variances, and covariances, making each lookup\n * performable in constant time and each variance calculation, only performed\n * once.\n *\n * Images must be a 2-Dimensional grayscale image.\n *\n * @method weberSsim\n * @param {ImageMatrix} pixels1 - The reference matrix\n * @param {ImageMatrix} pixels2 - The second matrix to compare against\n * @param {Options} options - The input options parameter\n * @returns {ImageMatrix} ssim_map - A matrix containing the map of computed\n * SSIMs\n * @public\n * @memberOf weberSsim\n */\nexport function weberSsim(\n  pixels1: ImageMatrix,\n  pixels2: ImageMatrix,\n  options: Options\n): MSSIMMatrix {\n  const { bitDepth, k1, k2, windowSize } = options\n  const L = 2 ** bitDepth - 1\n  const c1 = k1 * L * (k1 * L)\n  const c2 = k2 * L * (k2 * L)\n  const windowSquared = windowSize * windowSize\n  const pixels1Rounded = {\n    ...pixels1,\n    data: Int32Array.from(pixels1.data, (v) => v + 0.5),\n  }\n  const pixels2Rounded = {\n    ...pixels2,\n    data: Int32Array.from(pixels2.data, (v) => v + 0.5),\n  }\n  const sums1 = windowSums(pixels1Rounded, windowSize)\n  const variance1 = windowVariance(pixels1Rounded, sums1, windowSize)\n\n  const sums2 = windowSums(pixels2Rounded, windowSize)\n  const variance2 = windowVariance(pixels2Rounded, sums2, windowSize)\n  const covariance = windowCovariance(\n    pixels1Rounded,\n    pixels2Rounded,\n    sums1,\n    sums2,\n    windowSize\n  )\n  const size = sums1.data.length\n\n  let mssim = 0\n  const ssims = new Array(size)\n  for (let i = 0; i < size; ++i) {\n    const meanx = sums1.data[i] / windowSquared\n    const meany = sums2.data[i] / windowSquared\n    const varx = variance1.data[i] / 1024\n    const vary = variance2.data[i] / 1024\n    const cov = covariance.data[i] / 1024\n    const na = 2 * meanx * meany + c1\n    const nb = 2 * cov + c2\n    const da = meanx * meanx + meany * meany + c1\n    const db = varx + vary + c2\n    const ssim = (na * nb) / da / db\n    ssims[i] = ssim\n    if (i == 0) {\n      mssim = ssim\n    } else {\n      mssim = mssim + (ssim - mssim) / (i + 1)\n    }\n  }\n\n  return { data: ssims, width: sums1.width, height: sums1.height, mssim }\n}\n"],"sourceRoot":""}